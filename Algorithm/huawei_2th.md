# 1. 最小跳跃次数
<!-- TOC -->

- [1. 最小跳跃次数](#1-最小跳跃次数)
    - [1.1. 题目描述：](#11-题目描述)
    - [1.2. 解题思路](#12-解题思路)
    - [1.3. 实现代码](#13-实现代码)

<!-- /TOC -->
出自华为实习机试第二题：

## 1.1. 题目描述：

先输入一个数字代表数字总数  
然后依次输入几个数字，代表当前位置能跳跃的最大步数，求到最后一个位置的最小跳跃次数。  
**示例**  
输入：  
    7  
    2  
    3  
    2  
    1  
    2  
    1  
    5  
代表输入7个数，最小跳跃次数为3，可以是从2-2-2-5或者2-3-2-5，都是跳跃三次  
输出为3

---

## 1.2. 解题思路

仔细阅读一下题目，可以考虑遍历搜索的方法，也可以是动态规划，用迭代的方式来做，在时间复杂度和空间复杂度上都能有优势。  
将一组数记为：$a_0, a_1, a_2, ..., a_n$， 调到第$i$个数的最小跳跃次数为$res_i$。
则迭代公式为：  
$$res_1=0$$
$$res_i= min(res_{k}+1\quad if\quad a_k-i+k>=0|k=0,...,i-1 ),\quad i>1$$
迭代结果如下：

|    i     |  0  |  1  |  2  |  3  |  4  |  5  |  6
--------- | --- | --- | --- | --- | --- | --- | ---
**$a_i$** | 2   | 3   | 2   | 1   | 2   | 1   | 5
1         | 0   |     |     |     |     |     |
2         | 1   | ①   |     |     |     |     |
3         | 1   | 1   | ①   |     |     |     |
4         | *   | 2   | 2   | ②   |     |     |
5         | *   | 2   | 2   | 3   | ②   |     |
6         | *   | *   | *   | *   | 3   | ③   |
7         | *   | *   | *   | *   | 3   | 3   | ③
第$i$行的①代表$s_i=1$，②代表$s_i=2$，  
$i$行$j$列的数表示$res_{k}+1$，且满足$a_k-i+k>=0$即从第$i$个数可以一步调到第$j$个数  
$i$行$j$列的$*$表示不满足$a_k-i+k>=0$，即从第$i$个数无法一步调到第$j$个数

## 1.3. 实现代码
``` c++
// test_huawei.cpp: 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include <iostream>
using namespace std;

int main()
{
	int n = 0;
	cin >> n;
	int numlist[n], res[n];

	for (int i = 0; i < n; i++)
	{
		cin >> numlist[i];
		if (numlist[i] <= 0)
		{
			cout << "input error";
			return 0;
		}
	}

	res[0] = 0;
	int temp = 9999;
	for (int i = 1; i < n; i++)
	{
		int temp = 9999;
		for (int j = 0; j < i; j++)
		{
			if (numlist[j] - i + j>= 0)
			{
				int t = res[j] + 1;
				temp = temp <= (res[j] + 1) ? temp : (res[j] + 1);
			}
		}
		res[i] = temp;
	}
	cout << res[n-1] << endl;
	return 0;
}



```